{"name":"Gles2framework","tagline":"a simple framework for OpenGLES 2.0 ","body":"# gles2framework\r\n\r\n### a simple framework for OpenGLES 2.0 written in C\r\n\r\n*** Brief API notes at the end of the readme ***\r\n\r\nintended to help learning and tutorial writing\r\n\r\nCurrently supports XORG (linux) and the raspberry pi (none Xwindows proprietory EGL) on the pi it \r\ncan be run with or without X\r\n\r\ndependencies libpng, libEGL, libGLES (2.0), libode (0.12) for phystest, Chipmunk-6.1.1 for chiptest\r\n\r\npkg-config, build-esentials and development libraries must be installed to compile the framework\r\n\r\n### Raspberry pi specifics\r\n\r\nif you have not compiled GLES source code on your pi before you may need to make a file called\r\n\r\n/etc/ld.so.conf.d/vc.conf\r\n\r\nit should contain just the line\r\n\r\n/opt/vc/lib\r\n\r\n##### raw mouse, keyboard and joystick on Raspberry pi\r\n\r\nWhen not using xwindows (ie via ssh) input including keyboard is now done entirely via\r\nthe kernel evdev interface.\r\n\r\nyou need some udev rules (this does open the way for keyloggers for the paranoid!)\r\n\r\nmake a file called /etc/udev/rules.d/99-evdev.rules (as root) it should contain the following\r\n\r\n\tKERNEL==\"event*\", NAME=\"input/%k\", MODE=\"0640\", GROUP=\"evdev\"\r\n\tKERNEL==\"mouse*\", NAME=\"input/%k\", MODE=\"0640\", GROUP=\"evdev\"\r\n\tKERNEL==\"js*\", NAME=\"input/%k\", MODE=\"0640\", GROUP=\"evdev\"\r\n\r\nyou need to add an new group and add your user account to the group (as root)\r\n\r\n\tgroupadd evdev\r\n\tusermod -a -G evdev your_user_name\r\n\r\nyou'll need to reboot\r\n\r\nYou can now run your programs from ssh and it will only use the Pi's attached\r\nusb keyboard rather than being confused with the ssh console\r\n\r\nediting files via ssh (sftp enabled editor) and compiling with a ssh console is the recommended\r\nway of developing with this framework\r\n\r\n\t\r\n### file structure for external libraries\r\n\r\nsome examples rely on external libraries they should be extracted and compiled in the same \r\ndirectory that you are working on the frame work like this:\r\n\r\n\tChipmunk-6.1.1        ode-0.12            gles2framework \r\n\r\n\r\n### phystest (ode example)\r\n\r\nthe rather hacky ODE example is only really for advanced users... compile ode from source \r\n(version v0.12) release you can then \r\n\r\nYou need it to use dSingle with trimesh support and you might want other things like custom cylinder\r\nvs cylinder colliders etc you won't get from the repo version \r\n\r\nset drawstuff=none for quicker build (no demos etc)\r\n\r\nrun ./configure --help in the ode directory.\r\n\r\n\r\n### chiptest (Chipmonk physics example)\r\n\r\na quick example showing some balls falling on some invisible slopes, niether the sprites or the \r\nposition of the slopes are scaled depending on the display size, so the sample will look \r\ndifferent on for example xorg or the pi (or even on the pi if using hdmi v's composite)\r\nand is a good example of why you should use scaled sizes!\r\n\r\nYou can pass parameters to cmake or edit CMakeLists.txt so as to NOT compile the demos, \r\nyou only need compile a static library\r\n\r\n\toption(BUILD_DEMOS \"Build the demo applications\" OFF)\r\n\toption(INSTALL_DEMOS \"Install the demo applications\" OFF)\r\n\toption(BUILD_SHARED \"Build and install the shared library\" OFF)\r\n\toption(BUILD_STATIC \"Build as static library\" ON)\r\n\toption(INSTALL_STATIC \"Install the static library\" OFF)\r\n\r\n\r\n## Project structure\r\n\r\n| |description|\r\n|------------|--------------------------------------------------------------|\r\n|-include|source code include files|\r\n|-kazmath|source code and docs for the kazmath library|\r\n|-lib|kazmath compiled as static lib goes here. Other libs may follow.  The framework may become a library|\r\n|-o|somewhere to put intermediate binary objects|\r\n|-src|source code for the framework|\r\n|-obj2opengl|script used to turn wavefront OBJ models into source code also contains script to build GBO objects|\r\n|-resources|holds textures, shaders and binary 3d models for the samples|\r\n|-examples|example code showing use of the framework|\r\n|Makefile|tells the compiler how to build the examples|\r\n|README.md|this file!|\r\n|TODO.md|aide memoire, ideas and inspiration for future development|\r\n\r\n#### kazmath\r\nthere is no need to seperatly compile the kazmath library for your platform kazmath sources are now \r\nautomatically compiled into a static library\r\n\r\nAll though the source is unchanged I have deleted everthing except the C source and the html \r\ndocumentation the full distribution of kazmath is available at https://github.com/Kazade/kazmath\r\n\r\n\r\n#### obj2opengl\r\n\r\nIn order to create code from OBJ files use this script, ensure you set the output file name to \r\nsomething like shape.c\r\n\r\nyou will have to manually make shape.h it should look something like this\r\n\r\n\textern float shapeVerts[];\r\n\textern float shapeTexCoords[];\r\n\textern float shapeNormals[];\r\n\textern unsigned int shapeNumVerts;\r\n\r\nin addition you will have to add a rule in the Makefile\r\n\r\nthis method is depricated you should use a GBO instead...\r\n\r\n\r\n### makeGBO script\r\n\r\nThis is a binary file format, a kind of compiled OBJ file which can be used instead of embedding \r\nyour objects in the executable (which can be wasteful in terms of ram) Once the object data is \r\npassed to the GPU the loaded data its based on is freed from memory...\r\n\r\nTo make a gbo (Gles Binary Object) file place your wavefront object into the same directory, if \r\nfor example the shape is called alien.obj then execute ./makeGBO.sh alien - note the lack of the \r\nfile extension it will output alien.gbo which you can then copy to your resources directory - \r\nsee loadObj command detailed below.  makeGBO.sh relies on obj2opengl which must be in the same \r\ndirectory, it also needs at least the build esentials if going on another (artists) machine.\r\n\r\n## support routines\r\n_____\r\n\r\n__int loadPNG(const char *filename);__\r\n\r\nloads a specified png file returning a GLES texture handle\r\n\r\n_____\r\n\r\n__int makeContext();__\r\n\r\ncreates a native window and sets up a GLES context within it\r\n\r\n_____\r\n\r\n__void closeContext();__\r\n\r\ncloses GLES context and window\r\n\r\n_____\r\n\r\n__GLuint create\\_shader(const char *filename, GLenum type);__\r\n\r\nreturns a GLES shader handle from a file you must specify what type of shader it is either \r\nGL\\_VERTEX\\_SHADER or GL\\_FRAGMENT\\_SHADER\r\n\r\n_____\r\n\r\n__GLuint getShaderLocation(int type, GLuint prog, const char *name);__\r\n\r\ngiven a type of shaderAttrib or shaderUniform, a shader program handle and a name for the attrib \r\nor uniform it returns a location handle\r\n\r\n_____\r\n\r\n__void initGlPrint(int w, int h);__\r\n\r\nThis initialises the resources used by the glPrintf you must supply the windows width and height\r\n\r\n_____\r\n\r\n__font_t* createFont(const char* tpath,uint cbase,float tHeight,float tLines, int fWidth, int fHeight);__\r\n\r\ntpath is the full path and of the texture for this font, cbase is the ascii code of the first character \r\ntHeight is the height in pixels of the texture, tLines specifies the number of lines in total the texture \r\ncontains (I think there is a bug with this!) fWidth and fHeight are the width and height a character\r\n\r\nTODO freeFont to release a fonts resources...\r\n_____\r\n\r\n__void glPrintf(float x, float y, font_t fnt, const char *fmt, ...);__\r\n\r\nthis behaves exactly like a normal printf except for the first two parameters which specify the starting coordinate \r\nyou must specify a previously created font structure to print with\r\n\r\n_____\r\n\r\n__void swapBuffers();__\r\n\r\nIn order isolate egl and native window handles use this routine instead of eglSwapBuffers\r\n\r\n_____\r\n\r\n__void doEvents();__\r\n\r\nthis should be called once a frame to update the key down boolean array and the mouse information\r\n\r\n_____\r\n\r\n__int* getMouse();__\r\n\r\nthis returns a pointer to an array of 3 ints the first 2 are the x and y mouse position the 3rd int \r\nis a bit field reflecting the state of the mouse buttons\r\n\r\n_____\r\n\r\n__bool* getKeys();__\r\n\r\nthis is an array of 256 bools, while a key is held down the coresponding bool is true, key values are defined in keys.h\r\n\r\n_____\r\n\r\n*** deprecated may be removed in later version ***\r\n\r\n__int createObj(struct obj\\_t *obj, int numVerts, float verts[], float txVert[], float norms[], char *vertShader, char *fragShader);__\r\n\r\npass an empty obj_t struct, the number of vertices and arrays of verts, texture coordinates and \r\nnormals, finally you need to specify the file names for the vert and frag shaders\r\n\r\n_____\r\n\r\n*** deprecated may be removed in later version ***\r\n\r\n__int createObjCopyShader(struct obj\\_t *obj, int numVerts, float verts[], float txVert[], float norms[], struct obj\\_t *sdrobj);__\r\n\r\nthis allows you to initialise a obj shape but using an existing obj's shader.\r\n\r\n_____\r\n\r\n__void drawObj(struct obj\\_t *obj, kmMat4 * combined, kmMat4 * mv, kmVec3 lightDir, kmVec3 viewDir);__\r\n\r\nthis draws an obj, you need to supply a combined model, view and projection matrices as well as a \r\ncombined model, view matrix for the lighting, light and view direction vectors are also needed for \r\nlighting\r\n\r\n_____\r\n\r\n__int getDisplayWidth();__ \r\n\r\n__int getDisplayHeight();__\r\n\r\nreturns full screen width and height, for now when not on Raspberry PI the \"screen\" is fixed to a \r\n640x480 window\r\n\r\n_____\r\n\r\n__int loadObj(struct obj\\_t *obj,const char *objFile, char *vert, char *frag);__\r\n\r\n__int loadObjCopyShader(struct obj\\_t *obj,const char *objFile, struct obj\\_t *sdrobj);__\r\n\r\nthese are basically the same as their createObj counterparts except the OBJ is loaded from a \r\ncompiled binary wavefront object instead of from embedded data.\r\n\r\n_____\r\n\r\n__void initSprite(int w, int h);__\r\n\r\n__void drawSprite(float x, float y, float w, float h, float a, int tex);__\r\n\r\nlike glPrinf the sprite subsystem must be initialised before use, pass the dimensions of the screen.\r\n\r\nwhen drawing a sprite you specify where you want it (x & y) the size of the sprite (w & h) the rotation (a) and which texture to use (tex)\r\n\r\n_____\r\n\r\n__void setMouseRelative(bool mode);__\r\n\r\nif mode is true the mouse will report relative position changes only, this is handy for mouse \r\nlook where you dont want the mouse constrained by the window. By default absolute mouse position \r\nis reported\r\n\r\n_____\r\n\r\n__struct joystick\\_t *getJoystick(int j);__\r\n\r\n__void updateJoystick(struct joystick\\_t *js);__\r\n\r\n__void releaseJoystick(struct joystick\\_t *js);__\r\n\r\nto get a pointer to a joystick call getJoystick with the index of the joystick 0-7\r\ncall this once only\r\n\r\nonce a frame call updateJoystick you will then have (in the joystick structure)\r\n\r\n\tjs->axis[0..7]\t\tupto 8 axes per joystick (signed short)\r\n\tjs->buttons\t\t\tlong - each bit represents a button\r\n\t\r\nwhen finished with a joystick you should call releaseJoystick to close its file\r\nhandle and free the structures memory.\r\n\r\n_____\r\n\r\n\r\n__void initPointClouds(const char* vertS, const char* fragS, float pntSize);__\r\n\r\n__struct pointCloud\\_t* createPointCloud(int size);__\r\n\r\n__void drawPointCloud(struct pointCloud\\_t* pntC,kmMat4* m);__\r\n\r\n__void freePointCloud(struct pointCloud\\_t* pntC);__\r\n\r\n\r\ninitPointClouds is used initialise the common shader used by the point clouds and set the size\r\nof the individual points (this can be changed on the fly later by changing a shader uniform)\r\n\r\ncreatePointCloud reserves space for the position and velocity components of each individual \r\npoint in a cloud\r\n\r\nwhen drawing a point cloud you must pass the combined model/view/projection matrix in\r\na similar manner to drawing obj shapes, note you must update the individual point positions\r\noptionally using the supplied velocity value for each point\r\n\r\nWhile it is ok to keep a point cloud around without drawing it for later use.\r\nWhen the resources used by the cloud need to be released call freePoint cloud\r\nthis frees the point cloud structure itself and the associated points data\r\n\r\n_____\r\n\r\n\r\n","google":"UA-37857096-1","note":"Don't delete this file! It's used internally to help with page regeneration."}